<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Advanced Creative Canvas</title>
  <style>
    /* Reset and Global Styles */
    :root {
      --primary-bg: #121212;
      --secondary-bg: #1e1e1e;
      --accent-color: #4a4a4a;
      --text-color: #e0e0e0;
      --highlight-color: #6200ee;
      --transition-speed: 0.3s;
      --sparkle-color: rgba(255, 215, 0, 1);
      --sparkle-size: 3px;
      --sparkle-speed: 0.02;
    }
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      transition: all var(--transition-speed) ease;
    }

    html, body {
      height: 100%;
      overflow: hidden;
    }

    body {
      font-family: 'Inter', 'Helvetica Neue', sans-serif;
      background-color: var(--primary-bg);
      color: var(--text-color);
      line-height: 1.6;
    }

    /* App Container */
    .app-container {
      display: flex;
      height: 100vh;
      width: 100vw;
    }

    /* Sidebar Styles */
    .sidebar {
      width: 300px;
      background-color: var(--secondary-bg);
      padding: 20px;
      display: flex;
      flex-direction: column;
      border-right: 2px solid var(--accent-color);
      overflow-y: auto;
    }

    .tool-section {
      margin-bottom: 20px;
      background-color: var(--accent-color);
      border-radius: 8px;
      padding: 15px;
    }

    .tool-section h3 {
      margin-bottom: 10px;
      font-size: 1.1em;
    }

    .tool-btn {
      display: block;
      width: 100%;
      padding: 10px;
      margin-bottom: 10px;
      background-color: var(--highlight-color);
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      text-transform: uppercase;
      font-weight: bold;
      transition: transform 0.2s, background-color 0.2s;
    }

    .tool-btn:hover {
      transform: scale(1.05);
      background-color: #7c3aff;
    }

    .color-picker, .emoji-picker-container, .label-tools {
      display: flex;
      flex-direction: column;
      gap: 15px;
      margin-bottom: 15px;
    }

    .input-container {
      position: relative;
      width: 100%;
      margin-bottom: 15px;
    }

    .input-container canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 0;
    }

    .input-container input, .input-container label {
      position: relative;
      z-index: 1;
    }

    .color-picker label, .stroke-width-container label {
      display: block;
      margin-bottom: 5px;
      font-size: 0.9em;
    }

    .color-picker input, .stroke-width-container input {
      width: 100%;
      height: 40px;
      border: 2px solid var(--accent-color);
      background-color: var(--primary-bg);
      color: var(--text-color);
      cursor: pointer;
      border-radius: 5px;
    }

    .stroke-width-container {
      display: flex;
      flex-direction: column;
    }

    .stroke-width-container input[type="range"] {
      width: 100%;
      cursor: pointer;
    }

    /* Emoji Picker */
    .emoji-picker {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .emoji-btn {
      font-size: 1.5em;
      cursor: pointer;
      padding: 5px;
      border: none;
      background: none;
      transition: transform 0.2s;
    }

    .emoji-btn:hover {
      transform: scale(1.3);
    }

    /* Label Tools */
    .label-input {
      width: 100%;
      padding: 8px;
      border: 1px solid var(--accent-color);
      border-radius: 5px;
      margin-bottom: 10px;
      background-color: var(--primary-bg);
      color: var(--text-color);
    }

    .label-tools {
      display: flex;
      flex-direction: column;
      margin-bottom: 15px;
    }

    /* Canvas Area */
    .canvas-container {
      flex-grow: 1;
      position: relative;
      background: linear-gradient(45deg, #1a1a2e, #16213e);
      overflow: hidden;
    }

    #mainCanvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      cursor: crosshair;
      background: rgba(255,255,255,0.05);
    }

    /* Layer Management */
    .layer-panel {
      position: absolute;
      top: 20px;
      right: 20px;
      background-color: rgba(30, 30, 30, 0.9);
      border-radius: 10px;
      padding: 15px;
      max-height: 400px;
      width: 250px;
      overflow-y: auto;
      box-shadow: 0 4px 8px rgba(0,0,0,0.2);
    }

    .layer-panel h3 {
      margin-bottom: 10px;
      font-size: 1.1em;
    }

    .layer-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background-color: var(--accent-color);
      margin-bottom: 10px;
      padding: 8px;
      border-radius: 5px;
      font-size: 0.9em;
    }

    .layer-controls {
      display: flex;
      gap: 5px;
    }

    .layer-controls button {
      background: none;
      border: none;
      color: var(--text-color);
      cursor: pointer;
      font-size: 1em;
    }

    /* Resize Handles Styles */
    .resize-handle {
      position: absolute;
      width: 8px;
      height: 8px;
      background: var(--highlight-color);
      border: 1px solid #fff;
      cursor: nwse-resize;
      z-index: 1000;
    }

    .top-left { top: -4px; left: -4px; cursor: nwse-resize; }
    .top-right { top: -4px; right: -4px; cursor: nesw-resize; }
    .bottom-left { bottom: -4px; left: -4px; cursor: nesw-resize; }
    .bottom-right { bottom: -4px; right: -4px; cursor: nwse-resize; }
    .top-mid { top: -4px; left: 50%; transform: translateX(-50%); cursor: ns-resize; width: 10px; }
    .bottom-mid { bottom: -4px; left: 50%; transform: translateX(-50%); cursor: ns-resize; width: 10px; }
    .mid-left { top: 50%; left: -4px; transform: translateY(-50%); cursor: ew-resize; height: 10px; }
    .mid-right { top: 50%; right: -4px; transform: translateY(-50%); cursor: ew-resize; height: 10px; }

    .rotate-handle {
      position: absolute;
      width: 10px;
      height: 10px;
      background: var(--highlight-color);
      border: 1px solid #fff;
      border-radius: 50%;
      cursor: pointer;
      z-index: 1001;
      top: -10px;
      left: 50%;
      transform: translateX(-50%);
    }

    /* Ruler Tool Styles */
    .ruler-line {
      position: absolute;
      background-color: var(--highlight-color);
      height: 2px;
      z-index: 1000;
    }

    .ruler-label {
      position: absolute;
      background-color: rgba(0,0,0,0.7);
      color: #fff;
      padding: 2px 4px;
      border-radius: 3px;
      font-size: 12px;
      transform: translate(-50%, -100%);
      white-space: nowrap;
    }

    /* Sparkle Canvas */
    .sparkle-canvas {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
      z-index: 2000;
    }

    /* Responsive Design */
    @media (max-width: 1024px) {
      .sidebar {
        width: 250px;
      }
      .layer-panel {
        width: 200px;
      }
    }

    @media (max-width: 768px) {
      .app-container {
        flex-direction: column;
      }
      .sidebar {
        width: 100%;
        height: auto;
      }
      .layer-panel {
        position: static;
        width: 100%;
        margin-top: 20px;
      }
    }
  </style>
</head>
<body>
  <div class="app-container">
    <!-- Sidebar -->
    <div class="sidebar">
      <div class="tool-section">
        <h3>Drawing Tools</h3>
        <button class="tool-btn" id="freeDrawBtn">Free Draw</button>
        <button class="tool-btn" id="rectangleBtn">Rectangle</button>
        <button class="tool-btn" id="circleBtn">Circle</button>
        <button class="tool-btn" id="lineBtn">Line</button>
        <button class="tool-btn" id="contourBtn">Contour Maker</button>
        <button class="tool-btn" id="rulerBtn">Ruler</button> <!-- Ruler Tool -->
      </div>
      <div class="tool-section">
        <h3>Selection Tools</h3>
        <button class="tool-btn" id="selectBtn">Select</button>
        <button class="tool-btn" id="resizeBtn">Resize</button>
        <button class="tool-btn" id="rotateBtn">Rotate</button>
      </div>
      <div class="tool-section">
        <h3>Label Tools</h3>
        <div class="label-tools">
          <input type="text" class="label-input" id="labelInput" placeholder="Enter Label Text">
          <button class="tool-btn" id="addLabelBtn">Add Label</button>
          <input type="color" id="labelColorPicker" value="#FFFFFF">
        </div>
      </div>
      <div class="tool-section">
        <h3>Color & Style</h3>
        <div class="color-picker">
          <div class="input-container">
            <canvas></canvas>
            <label for="strokeColorPicker">Stroke Color</label>
            <input type="color" id="strokeColorPicker" value="#4a4a4a">
          </div>
          <div class="input-container">
            <canvas></canvas>
            <label for="fillColorPicker">Fill Color</label>
            <input type="color" id="fillColorPicker" value="#6200ee">
          </div>
        </div>
        <div class="stroke-width-container">
          <label for="strokeWidth">Stroke Width</label>
          <div class="input-container">
            <canvas></canvas>
            <input type="range" id="strokeWidth" min="1" max="20" value="3">
          </div>
        </div>
      </div>

      <div class="tool-section">
        <h3>Emojis</h3>
        <div class="emoji-picker">
          <!-- Existing Emojis -->
          <button class="emoji-btn" data-emoji="üöó">üöó</button>
          <button class="emoji-btn" data-emoji="üÖøÔ∏è">üÖøÔ∏è</button>
          <button class="emoji-btn" data-emoji="üõ£Ô∏è">üõ£Ô∏è</button>
          <button class="emoji-btn" data-emoji="üöß">üöß</button>
          <button class="emoji-btn" data-emoji="üèûÔ∏è">üèûÔ∏è</button>
          <button class="emoji-btn" data-emoji="üö¶">üö¶</button>
          <!-- New Road-Related Emojis -->
          <button class="emoji-btn" data-emoji="üõ§Ô∏è">üõ§Ô∏è</button> <!-- Railway Track -->
          <button class="emoji-btn" data-emoji="üöè">üöè</button> <!-- Bus Stop -->
          <button class="emoji-btn" data-emoji="üö≤">üö≤</button> <!-- Bicycle -->
          <button class="emoji-btn" data-emoji="üèéÔ∏è">üèéÔ∏è</button> <!-- Racing Car -->
          <button class="emoji-btn" data-emoji="üöç">üöç</button> <!-- Bus -->
          <button class="emoji-btn" data-emoji="üöô">üöô</button> <!-- Recreational Vehicle -->
          <button class="emoji-btn" data-emoji="üõµ">üõµ</button> <!-- Motor Scooter -->
          <button class="emoji-btn" data-emoji="üöõ">üöõ</button> <!-- Articulated Lorry -->
          <button class="emoji-btn" data-emoji="üöì">üöì</button> <!-- Police Car -->
          <button class="emoji-btn" data-emoji="üöë">üöë</button> <!-- Ambulance -->
          <button class="emoji-btn" data-emoji="üöö">üöö</button> <!-- Delivery Truck -->
          <button class="emoji-btn" data-emoji="üõ∫">üõ∫</button> <!-- Auto Rickshaw -->
          <!-- Add more road-related emojis as needed -->
        </div>
      </div>

      <div class="tool-section">
        <h3>Actions</h3>
        <button class="tool-btn" id="undoBtn">Undo</button>
        <button class="tool-btn" id="redoBtn">Redo</button>
        <button class="tool-btn" id="clearBtn">Clear</button>
        <button class="tool-btn" id="exportBtn">Export</button>
      </div>
    </div>

    <!-- Canvas Container -->
    <div class="canvas-container">
      <!-- Embedded DALL¬∑E sample image (1√ó1 pixel in base64) -->
      <img
        src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGMAAQAADQABX2lGZQAAAABJRU5ErkJggg=="
        alt="DALL¬∑E sample"
        style="position: absolute; top: 10px; left: 10px; width: 1px; height: 1px;"
      />

      <canvas id="mainCanvas"></canvas>
      
      <!-- Layer Management Panel -->
      <div class="layer-panel">
        <h3>Layers</h3>
        <div id="layerList">
          <!-- Layers will be dynamically added here -->
        </div>
      </div>
    </div>
  </div>

  <!-- Sparkle Canvas -->
  <canvas class="sparkle-canvas"></canvas>

  <script>
    // Sparkle Effect Module
    const SparkleEffect = (() => {
      const canvas = document.querySelector('.sparkle-canvas');
      const ctx = canvas.getContext('2d');

      function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);

      class Particle {
        constructor(x, y) {
          this.x = x;
          this.y = y;
          this.size = Math.random() * 3 + 1;
          this.speedX = Math.random() * 3 - 1.5;
          this.speedY = Math.random() * -3 - 1;
          this.opacity = 1;
        }
        update() {
          this.x += this.speedX;
          this.y += this.speedY;
          this.opacity -= 0.02;
        }
        draw() {
          ctx.fillStyle = `rgba(255, 215, 0, ${this.opacity})`;
          ctx.beginPath();
          ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      const particles = [];
      function createParticles(x, y) {
        for (let i = 0; i < 5; i++) {
          particles.push(new Particle(x, y));
        }
      }

      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        for (let i = particles.length - 1; i >= 0; i--) {
          particles[i].update();
          particles[i].draw();
          if (particles[i].opacity <= 0) {
            particles.splice(i, 1);
          }
        }
        requestAnimationFrame(animate);
      }
      animate();

      return {
        createParticles,
      };
    })();

    // Advanced Drawing Tool Class
    class AdvancedDrawingTool {
      constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');

        // Initialize rulers before any dependent methods
        this.rulers = [];

        // Initialize history
        this.history = [];
        this.historyIndex = -1;

        // Initialize other properties
        this.currentTool = 'freeDraw'; // default tool
        this.isDrawing = false;
        this.isDraggingEmoji = false;
        this.isResizing = false;
        this.selectedResizeHandle = null;
        this.resizeStartX = 0;
        this.resizeStartY = 0;
        this.isRotating = false;
        this.rotateAngle = 0;
        this.selectedRotateHandle = null;

        this.lastX = 0;
        this.lastY = 0;
        this.startX = 0;
        this.startY = 0;

        this.emojis = [];
        this.selectedEmoji = null;
        this.dragOffsetX = 0;
        this.dragOffsetY = 0;
        this.labels = [];
        this.selectedLabel = null;
        this.isDraggingLabel = false;
        this.labelDragOffsetX = 0;
        this.labelDragOffsetY = 0;

        this.selectedShape = null;
        this.resizeBox = null;
        this.rotateHandle = null;

        // Setup canvas and initial state
        this.setupCanvas();
        this.saveState();

        // Initialize event listeners
        this.initializeListeners();
      }

      setupCanvas() {
        this.resizeCanvas();
        this.ctx.lineCap = 'round';
        this.ctx.strokeStyle = document.getElementById('strokeColorPicker').value;
        this.ctx.fillStyle = document.getElementById('fillColorPicker').value;
        this.ctx.lineWidth = document.getElementById('strokeWidth').value;
      }

      initializeListeners() {
        // Tool Buttons
        document.getElementById('freeDrawBtn').addEventListener('click', () => this.setTool('freeDraw'));
        document.getElementById('rectangleBtn').addEventListener('click', () => this.setTool('rectangle'));
        document.getElementById('circleBtn').addEventListener('click', () => this.setTool('circle'));
        document.getElementById('lineBtn').addEventListener('click', () => this.setTool('line'));
        document.getElementById('contourBtn').addEventListener('click', () => this.setTool('contour'));
        document.getElementById('rulerBtn').addEventListener('click', () => this.setTool('ruler'));

        document.getElementById('selectBtn').addEventListener('click', () => this.setTool('select'));
        document.getElementById('resizeBtn').addEventListener('click', () => this.setTool('resize'));
        document.getElementById('rotateBtn').addEventListener('click', () => this.setTool('rotate'));

        // Color and Stroke Width
        document.getElementById('strokeColorPicker').addEventListener('change', (e) => {
          this.ctx.strokeStyle = e.target.value;
        });
        document.getElementById('fillColorPicker').addEventListener('change', (e) => {
          this.ctx.fillStyle = e.target.value;
        });
        document.getElementById('strokeWidth').addEventListener('input', (e) => {
          this.ctx.lineWidth = e.target.value;
        });

        // Emoji Picker
        const emojiPicker = document.querySelector('.emoji-picker');
        emojiPicker.addEventListener('click', (e) => {
          if (e.target.classList.contains('emoji-btn')) {
            const emoji = e.target.getAttribute('data-emoji');
            this.selectEmoji(emoji);
          }
        });

        // Add Label
        document.getElementById('addLabelBtn').addEventListener('click', () => this.addLabel());

        // Label Color Picker
        document.getElementById('labelColorPicker').addEventListener('change', (e) => {
          this.labelColor = e.target.value;
        });

        // Canvas Mouse Events
        this.canvas.addEventListener('mousedown', (e) => this.onMouseDown(e));
        this.canvas.addEventListener('mousemove', (e) => this.onMouseMove(e));
        this.canvas.addEventListener('mouseup', (e) => this.onMouseUp(e));
        this.canvas.addEventListener('mouseout', (e) => this.onMouseUp(e));

        // Action Buttons
        document.getElementById('undoBtn').addEventListener('click', () => this.undo());
        document.getElementById('redoBtn').addEventListener('click', () => this.redo());
        document.getElementById('clearBtn').addEventListener('click', () => this.clearCanvas());
        document.getElementById('exportBtn').addEventListener('click', () => this.exportCanvas());

        // Initialize Particle Effects
        this.initializeParticleEffects();

        // Handle window resize
        window.addEventListener('resize', () => this.resizeCanvas());

        // Sparkle Effect on Label Input
        document.querySelectorAll('input[type="text"], textarea, .label-input').forEach((element) => {
          element.addEventListener('input', (event) => {
            const rect = event.target.getBoundingClientRect();
            const cursorPosition = event.target.selectionStart;
            const textBeforeCursor = event.target.value.substring(0, cursorPosition);
            const tempSpan = document.createElement('span');
            tempSpan.style.position = 'absolute';
            tempSpan.style.visibility = 'hidden';
            tempSpan.style.whiteSpace = 'pre';
            tempSpan.style.font = window.getComputedStyle(event.target).font;
            tempSpan.textContent = textBeforeCursor;
            document.body.appendChild(tempSpan);
            const cursorX = rect.left + tempSpan.offsetWidth;
            const cursorY = rect.top + rect.height / 2;
            document.body.removeChild(tempSpan);
            SparkleEffect.createParticles(cursorX, cursorY);
          });
        });
      }

      resizeCanvas() {
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = this.canvas.width;
        tempCanvas.height = this.canvas.height;
        tempCtx.drawImage(this.canvas, 0, 0);

        this.canvas.width = this.canvas.parentElement.clientWidth;
        this.canvas.height = this.canvas.parentElement.clientHeight;
        this.ctx.drawImage(tempCanvas, 0, 0);
        this.render();
      }

      setTool(tool) {
        this.currentTool = tool;
        this.selectedShape = null;
        this.resizeBox = null;
        this.rotateHandle = null;
        this.canvas.style.cursor = 'default';

        switch(tool) {
          case 'freeDraw':
          case 'contour':
            this.canvas.style.cursor = 'crosshair';
            break;
          case 'select':
          case 'resize':
          case 'rotate':
            this.canvas.style.cursor = 'pointer';
            break;
          case 'emoji':
            this.canvas.style.cursor = 'pointer';
            break;
          case 'label':
            this.canvas.style.cursor = 'text';
            break;
          case 'ruler':
            this.canvas.style.cursor = 'crosshair';
            break;
          default:
            this.canvas.style.cursor = 'default';
        }

        // Remove existing resize or rotate handles
        this.removeHandles();
      }

      selectEmoji(emoji) {
        this.setTool('emoji');
        this.selectedEmoji = {
          emoji: emoji,
          x: 0,
          y: 0,
          size: 24
        };
      }

      addLabel() {
        const labelText = document.getElementById('labelInput').value;
        if(labelText) {
          this.setTool('label');
        }
      }

      onMouseDown(e) {
        const { offsetX, offsetY } = e;

        // Add Label
        if (this.currentTool === 'label' && document.getElementById('labelInput').value) {
          this.labels.push({
            text: document.getElementById('labelInput').value,
            x: offsetX,
            y: offsetY,
            color: document.getElementById('labelColorPicker').value,
          });
          this.saveState();
          this.render();
          document.getElementById('labelInput').value = '';
          this.setTool('freeDraw');
          return;
        }

        // Add Emoji
        if (this.currentTool === 'emoji' && this.selectedEmoji) {
          this.selectedEmoji.x = offsetX;
          this.selectedEmoji.y = offsetY;
          this.emojis.push(this.selectedEmoji);
          this.saveState();
          this.render();
          this.selectedEmoji = null;
          return;
        }

        // Drag Emoji
        const clickedEmoji = this.getEmojiAtPosition(offsetX, offsetY);
        if (clickedEmoji) {
          this.isDraggingEmoji = true;
          this.selectedEmoji = clickedEmoji;
          this.dragOffsetX = offsetX - clickedEmoji.x;
          this.dragOffsetY = offsetY - clickedEmoji.y;
          return;
        }

        // Drag Label
        const clickedLabel = this.getLabelAtPosition(offsetX, offsetY);
        if (clickedLabel) {
          this.isDraggingLabel = true;
          this.selectedLabel = clickedLabel;
          this.labelDragOffsetX = offsetX - clickedLabel.x;
          this.labelDragOffsetY = offsetY - clickedLabel.y;
          return;
        }

        // Select Shape
        const shapeClicked = this.getShapeAtPosition(offsetX, offsetY);
        if (shapeClicked) {
          this.selectedShape = shapeClicked;
          if(this.currentTool === 'resize'){
            this.renderResizeBox(this.selectedShape);
          }
          if (this.currentTool === 'rotate') {
            this.renderRotateHandle(this.selectedShape);
          }
          return;
        }

        // Resize or Rotate Handle Clicked
        if(this.resizeBox && (this.currentTool === 'resize' || this.currentTool === 'rotate')) {
          const handleClicked = this.getResizeHandleAtPosition(offsetX, offsetY);
          if(handleClicked) {
            this.selectedResizeHandle = handleClicked;
            this.isResizing = true;
            this.resizeStartX = offsetX;
            this.resizeStartY = offsetY;
            return;
          }
          if(this.currentTool === 'rotate') {
            const rotateClicked = this.getRotateHandleAtPosition(offsetX, offsetY);
            if (rotateClicked){
              this.selectedRotateHandle = rotateClicked;
              this.isRotating = true;
              this.resizeStartX = offsetX;
              this.resizeStartY = offsetY;
              return;
            }
          }
        }

        // Ruler Tool
        if(this.currentTool === 'ruler') {
          this.isDrawing = true;
          this.startX = offsetX;
          this.startY = offsetY;
          this.rulerTemp = { startX, startY, endX: offsetX, endY: offsetY };
          return;
        }

        // Start Drawing
        this.isDrawing = true;
        this.lastX = offsetX;
        this.lastY = offsetY;
        this.startX = offsetX;
        this.startY = offsetY;
      }

      onMouseMove(e) {
        const { offsetX, offsetY } = e;

        // Dragging Emoji
        if (this.isDraggingEmoji && this.selectedEmoji) {
          this.selectedEmoji.x = offsetX - this.dragOffsetX;
          this.selectedEmoji.y = offsetY - this.dragOffsetY;
          this.render();
          return;
        }

        // Dragging Label
        if (this.isDraggingLabel && this.selectedLabel) {
          this.selectedLabel.x = offsetX - this.labelDragOffsetX;
          this.selectedLabel.y = offsetY - this.labelDragOffsetY;
          this.render();
          return;
        }

        // Resizing Shape
        if(this.isResizing && this.selectedShape){
          this.resizeShape(offsetX, offsetY);
          this.renderResizeBox(this.selectedShape);
          return;
        }

        // Rotating Shape
        if(this.isRotating && this.selectedShape){
          this.rotateShape(offsetX, offsetY);
          this.renderRotateHandle(this.selectedShape);
          return;
        }

        // Ruler Tool Drawing
        if(this.currentTool === 'ruler' && this.isDrawing && this.rulerTemp){
          this.rulerTemp.endX = offsetX;
          this.rulerTemp.endY = offsetY;
          this.render();
          this.drawRuler(this.rulerTemp);
          return;
        }

        // Drawing Tools
        if (!this.isDrawing) return;

        this.ctx.beginPath();
        switch(this.currentTool) {
          case 'freeDraw':
            this.ctx.moveTo(this.lastX, this.lastY);
            this.ctx.lineTo(offsetX, offsetY);
            this.ctx.stroke();
            this.lastX = offsetX;
            this.lastY = offsetY;
            break;
          case 'line':
            this.restoreLastState();
            this.ctx.moveTo(this.startX, this.startY);
            this.ctx.lineTo(offsetX, offsetY);
            this.ctx.stroke();
            break;
          case 'rectangle':
            this.restoreLastState();
            const width = offsetX - this.startX;
            const height = offsetY - this.startY;
            this.ctx.strokeRect(this.startX, this.startY, width, height);
            break;
          case 'circle':
            this.restoreLastState();
            const radius = Math.sqrt(
              Math.pow(offsetX - this.startX, 2) +
              Math.pow(offsetY - this.startY, 2)
            );
            this.ctx.beginPath();
            this.ctx.arc(this.startX, this.startY, radius, 0, Math.PI * 2);
            this.ctx.stroke();
            break;
          case 'contour':
            this.ctx.strokeStyle = '#FF8C00';
            this.ctx.moveTo(this.lastX, this.lastY);
            this.ctx.lineTo(offsetX, offsetY);
            this.ctx.stroke();
            this.lastX = offsetX;
            this.lastY = offsetY;
            break;
        }
      }

      onMouseUp(e) {
        // Stop dragging Emoji
        if (this.isDraggingEmoji) {
          this.isDraggingEmoji = false;
          this.saveState();
          return;
        }

        // Stop dragging Label
        if (this.isDraggingLabel) {
          this.isDraggingLabel = false;
          this.saveState();
          return;
        }

        // Stop resizing
        if (this.isResizing) {
          this.isResizing = false;
          this.selectedResizeHandle = null;
          this.saveState();
          return;
        }

        // Stop rotating
        if(this.isRotating){
          this.isRotating = false;
          this.selectedRotateHandle = null;
          this.saveState();
          return;
        }

        // Finish Ruler Tool
        if(this.currentTool === 'ruler' && this.isDrawing && this.rulerTemp){
          this.isDrawing = false;
          this.rulers.push({ ...this.rulerTemp });
          this.saveState();
          this.rulerTemp = null;
          this.render();
          return;
        }

        // Finish Drawing
        if (!this.isDrawing) return;
        this.isDrawing = false;
        this.saveState();
      }

      getEmojiAtPosition(x, y) {
        for (let i = this.emojis.length - 1; i >= 0; i--) {
          const emoji = this.emojis[i];
          const size = emoji.size;
          if (x >= emoji.x - size && x <= emoji.x + size &&
              y >= emoji.y - size && y <= emoji.y + size) {
            return emoji;
          }
        }
        return null;
      }

      getLabelAtPosition(x, y) {
        for (let i = this.labels.length - 1; i >= 0; i--) {
          const label = this.labels[i];
          this.ctx.font = "16px Arial";
          const textWidth = this.ctx.measureText(label.text).width;
          const textHeight = 16; // Approximate height
          if (x >= label.x && x <= label.x + textWidth &&
              y >= label.y - textHeight && y <= label.y) {
            return label;
          }
        }
        return null;
      }

      getRulerAtPosition(x, y) {
        // Implement ruler selection if needed
        // Currently, rulers are not selectable
        return null;
      }

      getShapeAtPosition(x, y) {
        if(this.history.length === 0) return null;
        const currentState = this.history[this.historyIndex].imageData;
        let shape = null;
        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = this.canvas.width;
        tempCanvas.height = this.canvas.height;
        tempCtx.putImageData(currentState, 0, 0);

        const pixelData = tempCtx.getImageData(x, y, 1, 1).data;
        if(pixelData[3] !== 0){
          shape = { x, y };
        }
        return shape;
      }

      renderEmojis() {
        this.emojis.forEach(emojiObj => {
          this.ctx.font = `${emojiObj.size}px Arial`;
          this.ctx.fillText(emojiObj.emoji, emojiObj.x, emojiObj.y);
        });
      }

      renderLabels() {
        this.labels.forEach(labelObj => {
          this.ctx.font = "16px Arial";
          this.ctx.fillStyle = labelObj.color || '#000';
          this.ctx.fillText(labelObj.text, labelObj.x, labelObj.y);
        });
      }

      renderRulers() {
        if (!Array.isArray(this.rulers)) {
          console.warn('Rulers data is not an array:', this.rulers);
          this.rulers = [];
        }
        this.rulers.forEach(ruler => {
          this.drawRuler(ruler);
        });
      }

      drawRuler(ruler) {
        const { startX, startY, endX, endY } = ruler;
        const deltaX = endX - startX;
        const deltaY = endY - startY;
        const length = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
        const angle = Math.atan2(deltaY, deltaX);

        // Draw line
        this.ctx.strokeStyle = '#FFD700';
        this.ctx.lineWidth = 2;
        this.ctx.beginPath();
        this.ctx.moveTo(startX, startY);
        this.ctx.lineTo(endX, endY);
        this.ctx.stroke();

        // Draw label
        this.ctx.fillStyle = '#FFD700';
        this.ctx.font = '14px Arial';
        this.ctx.fillText(`${Math.round(length)} px`, (startX + endX) / 2, (startY + endY) / 2 - 10);
      }

      renderRulerTemp() {
        if(this.rulerTemp){
          this.drawRuler(this.rulerTemp);
        }
      }

      renderEmojisAndLabels() {
        this.renderEmojis();
        this.renderLabels();
        this.renderRulers();
      }

      restoreLastState() {
        if (this.historyIndex >= 0) {
          const lastState = this.history[this.historyIndex].imageData;
          this.ctx.putImageData(lastState, 0, 0);
          // Restore rulers
          this.rulers = [...this.history[this.historyIndex].rulers];
        }
      }

      saveState() {
        if (this.historyIndex < this.history.length - 1) {
          this.history = this.history.slice(0, this.historyIndex + 1);
        }
        const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
        const rulersCopy = JSON.parse(JSON.stringify(this.rulers));
        this.history.push({ imageData, rulers: rulersCopy });
        this.historyIndex++;
        this.updateLayerList();
      }

      undo() {
        if (this.historyIndex > 0) {
          this.historyIndex--;
          const previousState = this.history[this.historyIndex];
          this.ctx.putImageData(previousState.imageData, 0, 0);
          this.rulers = [...previousState.rulers];
          this.renderEmojisAndLabels();
        }
      }

      redo() {
        if (this.historyIndex < this.history.length - 1) {
          this.historyIndex++;
          const nextState = this.history[this.historyIndex];
          this.ctx.putImageData(nextState.imageData, 0, 0);
          this.rulers = [...nextState.rulers];
          this.renderEmojisAndLabels();
        }
      }

      clearCanvas() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.emojis = [];
        this.labels = [];
        this.rulers = [];
        this.saveState();
        this.render();
      }

      exportCanvas() {
        const dataURL = this.canvas.toDataURL('image/png');
        const link = document.createElement('a');
        link.download = 'creative-canvas.png';
        link.href = dataURL;
        link.click();
      }

      // Layer Management
      updateLayerList() {
        const layerList = document.getElementById('layerList');
        layerList.innerHTML = '';

        this.history.forEach((state, index) => {
          const layerItem = document.createElement('div');
          layerItem.classList.add('layer-item');
          layerItem.textContent = `Layer ${index + 1}`;

          const controls = document.createElement('div');
          controls.classList.add('layer-controls');

          const viewBtn = document.createElement('button');
          viewBtn.innerHTML = 'üëÅÔ∏è';
          viewBtn.title = 'View Layer';
          viewBtn.addEventListener('click', () => {
            this.historyIndex = index;
            this.render();
          });

          const deleteBtn = document.createElement('button');
          deleteBtn.innerHTML = '‚ùå';
          deleteBtn.title = 'Delete Layer';
          deleteBtn.addEventListener('click', () => {
            this.history.splice(index, 1);
            if (this.historyIndex >= this.history.length) {
              this.historyIndex = this.history.length - 1;
            }
            this.render();
            this.updateLayerList();
          });

          controls.appendChild(viewBtn);
          controls.appendChild(deleteBtn);
          layerItem.appendChild(controls);
          layerList.appendChild(layerItem);
        });
      }

      // Particle Effects for Color Pickers
      initializeParticleEffects() {
        const inputContainers = document.querySelectorAll('.input-container');
        inputContainers.forEach(container => {
          const canvas = container.querySelector('canvas');
          const input = container.querySelector('input');
          if (canvas && input) {
            const ctx = canvas.getContext('2d');
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            const particles = [];
            class ParticleEffect {
              constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = Math.random() * 2 + 1;
                this.color = 'rgba(255, 140, 0, 0.8)';
                this.speedX = (Math.random() - 0.5) * 2;
                this.speedY = (Math.random() - 0.5) * 2;
                this.opacity = 1;
              }

              update() {
                this.x += this.speedX;
                this.y += this.speedY;
                this.opacity -= 0.02;
              }

              draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color.replace('0.8', this.opacity.toFixed(2));
                ctx.fill();
              }
            }

            input.addEventListener('input', (e) => {
              const x = Math.random() * canvas.width;
              const y = Math.random() * canvas.height;
              particles.push(new ParticleEffect(x, y));
            });

            function animateParticles() {
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              particles.forEach((particle, index) => {
                particle.update();
                if (particle.opacity <= 0) {
                  particles.splice(index, 1);
                } else {
                  particle.draw(ctx);
                }
              });
              requestAnimationFrame(animateParticles);
            }
            animateParticles();

            window.addEventListener('resize', () => {
              canvas.width = container.clientWidth;
              canvas.height = container.clientHeight;
            });
          }
        });
      }

      // Render Resize Box with Handles
      renderResizeBox(shape){
        if (!shape) return;

        const tempCanvas = document.createElement('canvas');
        const tempCtx = tempCanvas.getContext('2d');
        tempCanvas.width = this.canvas.width;
        tempCanvas.height = this.canvas.height;
        tempCtx.drawImage(this.canvas, 0, 0);

        const pixelData = tempCtx.getImageData(0, 0, this.canvas.width, this.canvas.height);
        const points = [];
        for(let y = 0; y < this.canvas.height; y++) {
          for(let x = 0; x < this.canvas.width; x++) {
            const index = (y * this.canvas.width + x) * 4;
            if (pixelData.data[index+3] !== 0) {
              points.push({x, y});
            }
          }
        }

        if(points.length === 0) return;
        let minX = points[0].x;
        let minY = points[0].y;
        let maxX = points[0].x;
        let maxY = points[0].y;

        for(const point of points) {
          minX = Math.min(minX, point.x);
          minY = Math.min(minY, point.y);
          maxX = Math.max(maxX, point.x);
          maxY = Math.max(maxY, point.y);
        }

        const boxWidth = maxX - minX;
        const boxHeight = maxY - minY;
        this.resizeBox = {x: minX, y: minY, width: boxWidth, height: boxHeight};

        this.ctx.strokeStyle = '#fff';
        this.ctx.strokeRect(minX, minY, boxWidth, boxHeight);
        const handleSize = 8;

        // Render Resize Handles
        this.renderResizeHandle(minX - handleSize / 2 , minY - handleSize / 2, 'top-left');
        this.renderResizeHandle(maxX - handleSize / 2, minY - handleSize / 2, 'top-right');
        this.renderResizeHandle(minX - handleSize / 2, maxY - handleSize / 2, 'bottom-left');
        this.renderResizeHandle(maxX - handleSize / 2, maxY - handleSize / 2, 'bottom-right');

        this.renderResizeHandle(minX + boxWidth /2 - handleSize /2, minY - handleSize / 2, 'top-mid');
        this.renderResizeHandle(minX + boxWidth /2 - handleSize / 2, maxY - handleSize / 2, 'bottom-mid');

        this.renderResizeHandle(minX - handleSize/2 , minY + boxHeight /2 - handleSize/2 , 'mid-left');
        this.renderResizeHandle(maxX - handleSize /2, minY + boxHeight /2 - handleSize/2, 'mid-right');
      }

      renderResizeHandle(x, y, position) {
        const handle = document.createElement('div');
        handle.classList.add('resize-handle', position);
        handle.style.left = `${x}px`;
        handle.style.top = `${y}px`;
        this.canvas.parentNode.appendChild(handle);
      }

      getResizeHandleAtPosition(x, y){
        if(!this.resizeBox) return null;
        const handleSize = 8;
        const {x: boxX, y: boxY, width: boxWidth, height: boxHeight} = this.resizeBox;
        const handles = [
          {x: boxX - handleSize / 2 , y: boxY - handleSize / 2 , class:'top-left' },
          {x: boxX + boxWidth - handleSize / 2, y: boxY - handleSize / 2 , class:'top-right' },
          {x: boxX - handleSize / 2, y: boxY + boxHeight - handleSize / 2 , class:'bottom-left'},
          {x: boxX + boxWidth - handleSize / 2, y: boxY + boxHeight - handleSize / 2, class:'bottom-right'},

          {x: boxX + boxWidth / 2 - handleSize /2, y: boxY - handleSize / 2 , class:'top-mid'},
          {x: boxX + boxWidth / 2 - handleSize/ 2, y: boxY + boxHeight - handleSize / 2, class:'bottom-mid'},

          {x: boxX - handleSize/2, y: boxY + boxHeight /2 - handleSize/2, class:'mid-left'},
          {x: boxX + boxWidth - handleSize/2, y: boxY + boxHeight/2 - handleSize/2 , class:'mid-right'}
        ]

        for(const handle of handles){
          if (x >= handle.x && x <= handle.x + handleSize &&
              y >= handle.y && y <= handle.y + handleSize) {
            return handle.class;
          }
        }
        return null;
      }

      removeHandles(){
        const existingHandles = document.querySelectorAll('.resize-handle, .rotate-handle');
        existingHandles.forEach(handle => handle.remove());
      }

      resizeShape(mouseX, mouseY){
        if(!this.selectedShape || !this.resizeBox || !this.selectedResizeHandle) return;
        const { x: boxX, y: boxY, width: boxWidth, height: boxHeight } = this.resizeBox;
        const deltaX = mouseX - this.resizeStartX;
        const deltaY = mouseY - this.resizeStartY;
        this.resizeStartX = mouseX;
        this.resizeStartY = mouseY;

        let newBox = {...this.resizeBox};

        switch(this.selectedResizeHandle){
          case 'top-left':
            newBox.x = boxX + deltaX;
            newBox.y = boxY + deltaY;
            newBox.width = boxWidth - deltaX;
            newBox.height = boxHeight - deltaY;
            break;
          case 'top-right':
            newBox.y = boxY + deltaY;
            newBox.width = boxWidth + deltaX;
            newBox.height = boxHeight - deltaY;
            break;
          case 'bottom-left':
            newBox.x = boxX + deltaX;
            newBox.width = boxWidth - deltaX;
            newBox.height = boxHeight + deltaY;
            break;
          case 'bottom-right':
            newBox.width = boxWidth + deltaX;
            newBox.height = boxHeight + deltaY;
            break;
          case 'top-mid':
            newBox.y = boxY + deltaY;
            newBox.height = boxHeight - deltaY;
            break;
          case 'bottom-mid':
            newBox.height = boxHeight + deltaY;
            break;
          case 'mid-left':
            newBox.x = boxX + deltaX;
            newBox.width = boxWidth - deltaX;
            break;
          case 'mid-right':
            newBox.width = boxWidth + deltaX;
            break;
        }

        this.resizeBox = newBox;
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.restoreLastState();
        this.renderEmojisAndLabels();
        this.renderRulerTemp();
      }

      renderRotateHandle(shape) {
        if (!shape || !this.resizeBox) return;
        const { x, y, width, height } = this.resizeBox;
        const handleSize = 10;
        this.rotateHandle = {x: x + width/2 - handleSize/2, y: y - handleSize, size: handleSize}

        // Remove existing rotate handle to prevent duplicates
        const existingRotateHandle = document.querySelector('.rotate-handle');
        if(existingRotateHandle){
          existingRotateHandle.remove();
        }

        const rotateH = document.createElement('div');
        rotateH.classList.add('rotate-handle');
        rotateH.style.left = `${this.rotateHandle.x}px`;
        rotateH.style.top = `${this.rotateHandle.y}px`;
        this.canvas.parentNode.appendChild(rotateH);
      }

      getRotateHandleAtPosition(x, y){
        if(!this.rotateHandle) return null;
        const { x: rx, y: ry, size } = this.rotateHandle;
        if (x >= rx && x <= rx + size && y >= ry && y <= ry + size) {
          return this.rotateHandle;
        }
        return null;
      }

      rotateShape(mouseX, mouseY) {
        if(!this.selectedShape || !this.rotateHandle) return;
        const { x: rx, y: ry, size } = this.rotateHandle;
        const dx = mouseX - rx;
        const dy = mouseY - ry;
        const angle = Math.atan2(dy, dx);
        this.rotateAngle = angle;
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.restoreLastState();
        this.ctx.save();
        const centerX = this.resizeBox.x + this.resizeBox.width /2;
        const centerY = this.resizeBox.y + this.resizeBox.height /2;
        this.ctx.translate(centerX, centerY);
        this.ctx.rotate(this.rotateAngle);
        this.ctx.translate(-centerX, -centerY);
        this.renderEmojisAndLabels();
        this.ctx.restore();
      }

      // Ruler Tool Methods
      addRuler(ruler) {
        this.rulers.push(ruler);
        this.saveState();
        this.render();
      }

      // Selection Tools
      selectShape(shape) {
        this.selectedShape = shape;
        this.renderResizeBox(shape);
      }

      // Rendering Methods
      render() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        if (this.historyIndex >= 0) {
          const currentState = this.history[this.historyIndex].imageData;
          this.ctx.putImageData(currentState, 0, 0);
          this.rulers = [...this.history[this.historyIndex].rulers];
        }
        this.renderEmojisAndLabels();
        if (this.selectedShape) {
          if(this.currentTool === 'resize'){
            this.renderResizeBox(this.selectedShape);
          }
          if (this.currentTool === 'rotate') {
            this.renderRotateHandle(this.selectedShape);
          }
        }
      }

      // Safeguard rendering rulers
      renderRulers() {
        if (!Array.isArray(this.rulers)) {
          console.warn('Rulers data is not an array:', this.rulers);
          this.rulers = [];
        }
        this.rulers.forEach(ruler => {
          this.drawRuler(ruler);
        });
      }

      // Label and Emoji Rendering
      renderEmojis() {
        this.emojis.forEach(emojiObj => {
          this.ctx.font = `${emojiObj.size}px Arial`;
          this.ctx.fillText(emojiObj.emoji, emojiObj.x, emojiObj.y);
        });
      }

      renderLabels() {
        this.labels.forEach(labelObj => {
          this.ctx.font = "16px Arial";
          this.ctx.fillStyle = labelObj.color || '#000';
          this.ctx.fillText(labelObj.text, labelObj.x, labelObj.y);
        });
      }

      renderEmojisAndLabels() {
        this.renderEmojis();
        this.renderLabels();
        this.renderRulers();
      }

      // Restore canvas from history
      restoreLastState() {
        if (this.historyIndex >= 0) {
          const lastState = this.history[this.historyIndex].imageData;
          this.ctx.putImageData(lastState, 0, 0);
          // Restore rulers
          this.rulers = [...this.history[this.historyIndex].rulers];
        }
      }

      // History Management
      saveState() {
        if (this.historyIndex < this.history.length - 1) {
          this.history = this.history.slice(0, this.historyIndex + 1);
        }
        const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
        const rulersCopy = JSON.parse(JSON.stringify(this.rulers));
        this.history.push({ imageData, rulers: rulersCopy });
        this.historyIndex++;
        this.updateLayerList();
      }

      undo() {
        if (this.historyIndex > 0) {
          this.historyIndex--;
          const previousState = this.history[this.historyIndex];
          this.ctx.putImageData(previousState.imageData, 0, 0);
          this.rulers = [...previousState.rulers];
          this.renderEmojisAndLabels();
        }
      }

      redo() {
        if (this.historyIndex < this.history.length - 1) {
          this.historyIndex++;
          const nextState = this.history[this.historyIndex];
          this.ctx.putImageData(nextState.imageData, 0, 0);
          this.rulers = [...nextState.rulers];
          this.renderEmojisAndLabels();
        }
      }

      clearCanvas() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.emojis = [];
        this.labels = [];
        this.rulers = [];
        this.saveState();
        this.render();
      }

      exportCanvas() {
        const dataURL = this.canvas.toDataURL('image/png');
        const link = document.createElement('a');
        link.download = 'creative-canvas.png';
        link.href = dataURL;
        link.click();
      }

      // Layer Management
      updateLayerList() {
        const layerList = document.getElementById('layerList');
        layerList.innerHTML = '';

        this.history.forEach((state, index) => {
          const layerItem = document.createElement('div');
          layerItem.classList.add('layer-item');
          layerItem.textContent = `Layer ${index + 1}`;

          const controls = document.createElement('div');
          controls.classList.add('layer-controls');

          const viewBtn = document.createElement('button');
          viewBtn.innerHTML = 'üëÅÔ∏è';
          viewBtn.title = 'View Layer';
          viewBtn.addEventListener('click', () => {
            this.historyIndex = index;
            this.render();
          });

          const deleteBtn = document.createElement('button');
          deleteBtn.innerHTML = '‚ùå';
          deleteBtn.title = 'Delete Layer';
          deleteBtn.addEventListener('click', () => {
            this.history.splice(index, 1);
            if (this.historyIndex >= this.history.length) {
              this.historyIndex = this.history.length - 1;
            }
            this.render();
            this.updateLayerList();
          });

          controls.appendChild(viewBtn);
          controls.appendChild(deleteBtn);
          layerItem.appendChild(controls);
          layerList.appendChild(layerItem);
        });
      }

      // Resizing and Rotating Methods
      resizeShape(mouseX, mouseY){
        if(!this.selectedShape || !this.resizeBox || !this.selectedResizeHandle) return;
        const { x: boxX, y: boxY, width: boxWidth, height: boxHeight } = this.resizeBox;
        const deltaX = mouseX - this.resizeStartX;
        const deltaY = mouseY - this.resizeStartY;
        this.resizeStartX = mouseX;
        this.resizeStartY = mouseY;

        let newBox = {...this.resizeBox};

        switch(this.selectedResizeHandle){
          case 'top-left':
            newBox.x = boxX + deltaX;
            newBox.y = boxY + deltaY;
            newBox.width = boxWidth - deltaX;
            newBox.height = boxHeight - deltaY;
            break;
          case 'top-right':
            newBox.y = boxY + deltaY;
            newBox.width = boxWidth + deltaX;
            newBox.height = boxHeight - deltaY;
            break;
          case 'bottom-left':
            newBox.x = boxX + deltaX;
            newBox.width = boxWidth - deltaX;
            newBox.height = boxHeight + deltaY;
            break;
          case 'bottom-right':
            newBox.width = boxWidth + deltaX;
            newBox.height = boxHeight + deltaY;
            break;
          case 'top-mid':
            newBox.y = boxY + deltaY;
            newBox.height = boxHeight - deltaY;
            break;
          case 'bottom-mid':
            newBox.height = boxHeight + deltaY;
            break;
          case 'mid-left':
            newBox.x = boxX + deltaX;
            newBox.width = boxWidth - deltaX;
            break;
          case 'mid-right':
            newBox.width = boxWidth + deltaX;
            break;
        }

        this.resizeBox = newBox;
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.restoreLastState();
        this.renderEmojisAndLabels();
        this.renderRulerTemp();
      }

      rotateShape(mouseX, mouseY) {
        if(!this.selectedShape || !this.rotateHandle) return;
        const { x: rx, y: ry, size } = this.rotateHandle;
        const dx = mouseX - rx;
        const dy = mouseY - ry;
        const angle = Math.atan2(dy, dx);
        this.rotateAngle = angle;
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.restoreLastState();
        this.ctx.save();
        const centerX = this.resizeBox.x + this.resizeBox.width /2;
        const centerY = this.resizeBox.y + this.resizeBox.height /2;
        this.ctx.translate(centerX, centerY);
        this.ctx.rotate(this.rotateAngle);
        this.ctx.translate(-centerX, -centerY);
        this.renderEmojisAndLabels();
        this.ctx.restore();
      }
    }

    window.addEventListener('load', () => {
      const drawingTool = new AdvancedDrawingTool('mainCanvas');
    });
  </script>
</body>
</html>
