<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Drag and Drop Animation Builder â€“ Multi-Shape Advanced with Emoji Tools</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    /* Basic Reset & Layout */
    body {
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      font-family: sans-serif;
      background-color: #f0f0f0;
      overflow: auto;
    }
    /* Increase canvas/container size */
    #animationContainer {
      width: 80vw;
      height: 80vh;
      background-color: #ffffff;
      border: 1px solid #000;
      position: relative;
      margin-top: 20px;
    }
    /* Draggable shape style (supports translation, rotation & scale) */
    .draggable {
      width: 50px;
      height: 50px;
      background-color: #3498db;
      position: absolute;
      left: 0;
      top: 0;
      transition: left 0.8s ease, top 0.8s ease, transform 0.8s ease, background-color 0.8s ease;
      border-radius: 0;
      background-size: cover;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
    }
    /* Controls styling */
    #controls {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      width: 80vw;
      margin-top: 20px;
    }
    #controls button,
    #controls select,
    #controls input[type="number"],
    #controls input[type="color"],
    #controls input[type="text"],
    #controls input[type="range"] {
      margin: 5px;
      padding: 5px 10px;
      background-color: #3498db;
      color: #fff;
      border: none;
      cursor: pointer;
      border-radius: 4px;
      font-size: 14px;
    }
    /* New: Emoji Tools */
    #emojiTools {
      margin: 5px;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
    }
    #emojiTools button {
      margin: 3px;
      padding: 5px;
      font-size: 24px;
      background-color: #f1c40f;
      border: none;
      border-radius: 50%;
      cursor: pointer;
    }
    /* Active Shape selector */
    #activeShapeSelector {
      margin: 5px;
      padding: 5px 10px;
      background-color: #2ecc71;
      color: #fff;
      border: none;
      cursor: pointer;
      border-radius: 4px;
      font-size: 14px;
    }
    /* Timeline styling */
    #timeline {
      margin-top: 20px;
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
    }
    .timeline-btn {
      margin: 5px;
      padding: 5px 10px;
      background-color: #2ecc71;
      color: #fff;
      border: none;
      border-radius: 4px;
      font-size: 12px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <!-- Animation Container -->
  <div id="animationContainer"></div>
  
  <!-- Controls Panel -->
  <div id="controls">
    <button onclick="addNewShape()">Add New Shape</button>
    <button onclick="addKeyframe()">Add Keyframe</button>
    <button onclick="deleteKeyframe()">Delete Keyframe</button>
    <select id="activeShapeSelector" onchange="changeActiveShape(this.value)"></select>
    <select id="shapeSelector">
      <option value="square">Square</option>
      <option value="circle">Circle</option>
    </select>
    <input type="number" id="rotateInput" placeholder="Rotate (Â°)">
    <input type="range" id="scaleInput" min="0.5" max="2" step="0.1" value="1">
    <input type="number" id="speedInput" placeholder="Speed (s)">
    <input type="color" id="colorInput" value="#3498db">
    <input type="text" id="imageInput" placeholder="Custom Image URL">
    <button onclick="playAnimation()">Play</button>
    <button onclick="pauseAnimation()">Pause</button>
    <button onclick="saveAnimation()">Save Animation</button>
    <button onclick="openAnimation()">Open Animation</button>
  </div>
  
  <!-- Emoji Tools Panel -->
  <div id="emojiTools">
    <button onclick="addEmojiShape('ðŸ˜€')">ðŸ˜€</button>
    <button onclick="addEmojiShape('ðŸš€')">ðŸš€</button>
    <button onclick="addEmojiShape('ðŸ”¥')">ðŸ”¥</button>
    <button onclick="addEmojiShape('ðŸŽ‰')">ðŸŽ‰</button>
    <button onclick="addEmojiShape('ðŸ’Ž')">ðŸ’Ž</button>
    <!-- Add more emojis as desired -->
  </div>
  
  <!-- Timeline -->
  <div id="timeline"></div>
  
  <script>
    /******************************************************
     * Multi-Shape Drag and Drop Animation Builder â€“ Advanced & Multi-Shape
     ******************************************************/
    // Global: an array of shape objects; each shape object has: { element, keyframes }
    let shapeObjects = [];
    let activeShape = null; // currently selected shape object
    // To capture click coordinates for new shapes
    let lastClickPos = { x: 200, y: 200 }; // default center of 400x400 container
    
    // Update lastClickPos on container click
    document.getElementById('animationContainer').addEventListener('click', (e) => {
      const rect = e.currentTarget.getBoundingClientRect();
      lastClickPos = {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
      };
    });
    
    // Add new shape at last click position (or if emoji version, handled below)
    function addNewShape() {
      const newShape = document.createElement('div');
      newShape.classList.add('draggable');
      // Place new shape at lastClickPos (relative to container)
      newShape.style.left = `${lastClickPos.x}px`;
      newShape.style.top = `${lastClickPos.y}px`;
      // Default transform: no rotation, scale 1
      newShape.style.transform = `rotate(0deg) scale(1)`;
      // Append to container
      document.getElementById('animationContainer').appendChild(newShape);
      // Create shape object with its own keyframes array
      const shapeObj = { element: newShape, keyframes: [] };
      shapeObjects.push(shapeObj);
      updateActiveShapeSelector();
      changeActiveShape(shapeObjects.length - 1);
      addDragHandlers(newShape);
    }
    
    // Add new emoji shape (sets innerHTML to emoji)
    function addEmojiShape(emoji) {
      addNewShape();
      // Set the new shape's inner content to the emoji
      activeShape.element.textContent = emoji;
      // Increase font-size for clarity
      activeShape.element.style.fontSize = "32px";
    }
    
    // Update the "Active Shape" selector options
    function updateActiveShapeSelector() {
      const selector = document.getElementById('activeShapeSelector');
      selector.innerHTML = "";
      shapeObjects.forEach((shapeObj, index) => {
        const opt = document.createElement('option');
        opt.value = index;
        opt.textContent = "Shape " + (index + 1);
        selector.appendChild(opt);
      });
    }
    
    // Change the active shape based on dropdown selection
    function changeActiveShape(index) {
      activeShape = shapeObjects[parseInt(index)];
      updateControlsFromActiveShape();
      updateTimeline();
    }
    
    // Get current properties of the active shape (relative to container)
    function getCurrentShapeProps() {
      if(!activeShape) return {};
      const rect = activeShape.element.getBoundingClientRect();
      const containerRect = document.getElementById('animationContainer').getBoundingClientRect();
      const left = rect.left - containerRect.left;
      const top = rect.top - containerRect.top;
      // Get rotation and scale from computed transform
      let style = window.getComputedStyle(activeShape.element).transform;
      let rotate = 0, scale = 1;
      if(style && style !== "none") {
        const values = style.split('(')[1].split(')')[0].split(',');
        const a = parseFloat(values[0]);
        const b = parseFloat(values[1]);
        rotate = Math.round(Math.atan2(b, a) * (180/Math.PI));
        scale = Math.sqrt(a*a + b*b);
      } else {
        rotate = parseFloat(rotateInput.value) || 0;
        scale = parseFloat(scaleInput.value) || 1;
      }
      return {
        left,
        top,
        rotate,
        scale,
        color: activeShape.element.style.backgroundColor || "#3498db",
        image: activeShape.element.style.backgroundImage ? activeShape.element.style.backgroundImage.slice(5,-2) : "",
        shape: shapeSelector.value,
        speed: speedInput.value || 1
      };
    }
    
    // Update controls to reflect the active shape's current properties
    function updateControlsFromActiveShape() {
      if(!activeShape) return;
      const props = getCurrentShapeProps();
      shapeSelector.value = props.shape;
      rotateInput.value = props.rotate;
      scaleInput.value = props.scale;
      speedInput.value = props.speed || 1;
      colorInput.value = props.color;
      imageInput.value = props.image;
    }
    
    // Set properties on the active shape element
    function setShapeProperties(props) {
      if(!activeShape) return;
      const el = activeShape.element;
      if(props.left !== undefined) el.style.left = `${props.left}px`;
      if(props.top !== undefined) el.style.top = `${props.top}px`;
      if(props.rotate !== undefined && props.scale !== undefined) {
        el.style.transform = `rotate(${props.rotate}deg) scale(${props.scale})`;
      }
      if(props.color !== undefined) el.style.backgroundColor = props.color;
      if(props.image !== undefined) {
        if(props.image.trim() !== ""){
          el.style.backgroundImage = `url('${props.image}')`;
          el.style.backgroundSize = 'cover';
          el.style.backgroundColor = 'transparent';
        } else {
          el.style.backgroundImage = 'none';
        }
      }
      if(shapeSelector.value === "circle") {
        el.style.borderRadius = "50%";
      } else {
        el.style.borderRadius = "0";
      }
    }
    
    // Timeline update for active shape
    function updateTimeline() {
      timeline.innerHTML = "";
      if(!activeShape) return;
      activeShape.keyframes.forEach((kf, index) => {
        const btn = document.createElement('button');
        btn.className = 'timeline-btn';
        btn.textContent = `${index+1}: ${kf.time}`;
        btn.addEventListener('click', () => goToKeyframe(index));
        timeline.appendChild(btn);
      });
    }
    
    // Add a keyframe for active shape using current controls
    function addKeyframe() {
      if(!activeShape) return;
      const currentTime = new Date().toLocaleTimeString();
      const props = getCurrentShapeProps();
      const kf = {
        time: currentTime,
        position: { x: props.left, y: props.top },
        rotate: rotateInput.value || props.rotate,
        scale: scaleInput.value || props.scale,
        speed: parseFloat(speedInput.value) || 1,
        color: colorInput.value,
        image: imageInput.value,
        shape: shapeSelector.value
      };
      activeShape.keyframes.push(kf);
      updateTimeline();
    }
    
    function deleteKeyframe() {
      if(!activeShape || activeShape.keyframes.length === 0) return;
      activeShape.keyframes.pop();
      updateTimeline();
    }
    
    function goToKeyframe(index) {
      if(!activeShape) return;
      const kf = activeShape.keyframes[index];
      setShapeProperties({
        left: kf.position.x,
        top: kf.position.y,
        rotate: kf.rotate,
        scale: kf.scale,
        color: kf.color,
        image: kf.image
      });
      shapeSelector.value = kf.shape;
      rotateInput.value = kf.rotate;
      scaleInput.value = kf.scale;
      speedInput.value = kf.speed;
      colorInput.value = kf.color;
      imageInput.value = kf.image;
    }
    
    /********* Smooth Playback with Interpolation *********/
    let playbackActive = false, playRequest;
    let playbackIndex = 0, playbackStartTime, playbackDuration, startKF, endKF;
    
    function playAnimation() {
      if(!activeShape || activeShape.keyframes.length < 2) {
        alert("Need at least 2 keyframes for playback.");
        return;
      }
      playbackActive = true;
      playbackIndex = 0;
      startKF = activeShape.keyframes[0];
      endKF = activeShape.keyframes[1];
      playbackStartTime = performance.now();
      playbackDuration = endKF.speed * 1000;
      animatePlayback();
    }
    
    function animatePlayback() {
      if(!playbackActive) return;
      const now = performance.now();
      const t = (now - playbackStartTime) / playbackDuration;
      if(t < 1) {
        const lerp = (a, b, t) => a + (b - a) * t;
        const posX = lerp(startKF.position.x, endKF.position.x, t);
        const posY = lerp(startKF.position.y, endKF.position.y, t);
        const rotation = lerp(parseFloat(startKF.rotate), parseFloat(endKF.rotate), t);
        const scale = lerp(parseFloat(startKF.scale), parseFloat(endKF.scale), t);
        const color = (t < 0.5) ? startKF.color : endKF.color;
        setShapeProperties({ left: posX, top: posY, rotate: rotation, scale: scale, color: color, image: endKF.image });
        playRequest = requestAnimationFrame(animatePlayback);
      } else {
        playbackIndex++;
        if(playbackIndex >= activeShape.keyframes.length - 1) {
          playbackActive = false;
          return;
        }
        startKF = activeShape.keyframes[playbackIndex];
        endKF = activeShape.keyframes[playbackIndex + 1];
        playbackStartTime = performance.now();
        playbackDuration = endKF.speed * 1000;
        playRequest = requestAnimationFrame(animatePlayback);
      }
    }
    
    function pauseAnimation() {
      playbackActive = false;
      cancelAnimationFrame(playRequest);
    }
    
    /********* Draggable Behavior *********/
    function addDragHandlers(el) {
      let isDragging = false;
      el.addEventListener('mousedown', () => { isDragging = true; });
      window.addEventListener('mouseup', () => { isDragging = false; });
      animationContainer.addEventListener('mousemove', (e) => {
        if(isDragging) {
          const rect = animationContainer.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          setShapeProperties({ left: x, top: y });
        }
      });
    }
    
    /********* Local Save and Open *********/
    function saveAnimation() {
      // Save keyframes for all shapes
      const state = shapeObjects.map(shapeObj => shapeObj.keyframes);
      localStorage.setItem("animationState", JSON.stringify(state));
      alert("Animation state saved locally.");
    }
    
    function openAnimation() {
      const state = localStorage.getItem("animationState");
      if(state) {
        const allKeyframes = JSON.parse(state);
        allKeyframes.forEach((kfArray, index) => {
          if(shapeObjects[index]) {
            shapeObjects[index].keyframes = kfArray;
          }
        });
        if(shapeObjects.length > 0) changeActiveShape(0);
        updateTimeline();
        alert("Animation state loaded.");
      } else {
        alert("No saved animation found.");
      }
    }
    
    window.addEventListener('beforeunload', () => {
      const state = shapeObjects.map(shapeObj => shapeObj.keyframes);
      localStorage.setItem("animationState", JSON.stringify(state));
    });
    
    /********* Initialization *********/
    // Automatically add one shape on load and load saved state if available
    window.addEventListener('load', () => {
      addNewShape();
      const state = localStorage.getItem("animationState");
      if(state) {
        const allKeyframes = JSON.parse(state);
        if(allKeyframes.length > 0) {
          shapeObjects[0].keyframes = allKeyframes[0];
          updateTimeline();
        }
      }
    });
  </script>
</body>
</html>
