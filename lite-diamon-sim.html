<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Enhanced DIAMOND Simulation with Q-Learning and Interaction</title>
    <style>
        body { font-family: Arial, sans-serif; background-color: #fafafa; margin: 0; padding: 20px; }
        .container { max-width: 1200px; margin: auto; }
        h1 { color: #222; text-align: center; }
        .canvas-container { display: flex; justify-content: center; }
        canvas { border: 1px solid #999; background-color: #fff; margin: 10px; }
        .info { text-align: center; }
    </style>
</head>
<body>
    <div class="container">
        <h1>DIAMOND Simulation with Resource Interaction and Learning</h1>
        <div class="canvas-container">
            <canvas id="world-canvas" width="600" height="600"></canvas>
        </div>
        <div class="info">
            <p>Total Steps: <span id="total-steps">0</span></p>
        </div>
    </div>
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <script>
        let GRID_SIZE = 60;
        let CELL_SIZE = 10;
        let MAX_ENERGY = 100;
        let POPULATION_SIZE = 10;
        const RESOURCE_TYPES = ['food', 'water'];
        const THREAT_TYPES = ['predator', 'hazard'];
        const ACTIONS = ['up', 'down', 'left', 'right'];
        
        const worldCanvas = document.getElementById('world-canvas');
        const worldCtx = worldCanvas.getContext('2d');
        const stepsCounter = document.getElementById('total-steps');

        class Environment {
            constructor(gridSize) {
                this.gridSize = gridSize;
                this.state = this.createState(gridSize);
                this.resources = this.createResources(gridSize);
                this.threats = this.createThreats(gridSize);
            }

            createState(gridSize) {
                let state = [];
                for (let y = 0; y < gridSize; y++) {
                    let row = [];
                    for (let x = 0; x < gridSize; x++) {
                        row.push(null);
                    }
                    state.push(row);
                }
                return state;
            }

            createResources(gridSize) {
                let resources = [];
                const resourceCount = Math.floor(gridSize * gridSize * 0.05);
                for (let i = 0; i < resourceCount; i++) {
                    let type = RESOURCE_TYPES[Math.floor(Math.random() * RESOURCE_TYPES.length)];
                    let x = Math.floor(Math.random() * gridSize);
                    let y = Math.floor(Math.random() * gridSize);
                    resources.push({ x, y, type });
                    this.state[y][x] = { type: 'resource', resourceType: type };
                }
                return resources;
            }

            createThreats(gridSize) {
                let threats = [];
                const threatCount = Math.floor(gridSize * gridSize * 0.03);
                for (let i = 0; i < threatCount; i++) {
                    let type = THREAT_TYPES[Math.floor(Math.random() * THREAT_TYPES.length)];
                    let x = Math.floor(Math.random() * gridSize);
                    let y = Math.floor(Math.random() * gridSize);
                    threats.push({ x, y, type });
                    this.state[y][x] = { type: 'threat', threatType: type };
                }
                return threats;
            }
        }

        class Agent {
            constructor(env, id) {
                this.env = env;
                this.id = id;
                this.position = [Math.floor(GRID_SIZE / 2), Math.floor(GRID_SIZE / 2)];
                this.energy = MAX_ENERGY;
                this.alive = true;
                this.qTable = {};
                this.epsilon = 0.2; // Exploration factor
                this.alpha = 0.1;  // Learning rate
                this.gamma = 0.9;  // Discount factor
            }

            getState() {
                const [x, y] = this.position;
                return `${x},${y}`;
            }

            move() {
                if (!this.alive) return;

                const action = this.chooseAction();
                let [dx, dy] = [0, 0];
                switch (action) {
                    case 'up': dy = -1; break;
                    case 'down': dy = 1; break;
                    case 'left': dx = -1; break;
                    case 'right': dx = 1; break;
                }

                this.updatePosition(dx, dy);
                this.interactWithEnvironment();
                this.energy -= 1; // Decrease energy on each move

                if (this.energy <= 0) {
                    this.alive = false;
                }
            }

            updatePosition(dx, dy) {
                const newX = Math.min(Math.max(this.position[0] + dx, 0), GRID_SIZE - 1);
                const newY = Math.min(Math.max(this.position[1] + dy, 0), GRID_SIZE - 1);
                this.position = [newX, newY];
            }

            interactWithEnvironment() {
                const [x, y] = this.position;
                const cell = this.env.state[y][x];

                if (cell && cell.type === 'resource') {
                    this.energy = Math.min(this.energy + 20, MAX_ENERGY); // Gain energy
                    this.env.state[y][x] = null; // Remove resource after collection
                } else if (cell && cell.type === 'threat') {
                    this.energy -= 30; // Lose energy
                }
            }

            chooseAction() {
                const state = this.getState();
                if (Math.random() < this.epsilon || !this.qTable[state]) {
                    // Explore random action
                    return ACTIONS[Math.floor(Math.random() * ACTIONS.length)];
                } else {
                    // Exploit learned action
                    return this.getBestAction(state);
                }
            }

            getBestAction(state) {
                if (!this.qTable[state]) return ACTIONS[Math.floor(Math.random() * ACTIONS.length)];
                let bestAction = ACTIONS[0];
                let maxQ = this.qTable[state][bestAction] || 0;
                for (let action of ACTIONS) {
                    const qValue = this.qTable[state][action] || 0;
                    if (qValue > maxQ) {
                        maxQ = qValue;
                        bestAction = action;
                    }
                }
                return bestAction;
            }
        }

        class Simulation {
            constructor() {
                this.env = new Environment(GRID_SIZE);
                this.agents = this.initializeAgents();
                this.totalSteps = 0;
                this.run();
            }

            initializeAgents() {
                const agents = [];
                for (let i = 0; i < POPULATION_SIZE; i++) {
                    agents.push(new Agent(this.env, i + 1));
                }
                return agents;
            }

            run() {
                setInterval(() => {
                    this.totalSteps++;
                    stepsCounter.textContent = this.totalSteps;
                    this.update();
                    this.draw();
                }, 100);
            }

            update() {
                for (let agent of this.agents) {
                    agent.move();
                }
            }

            draw() {
                worldCtx.clearRect(0, 0, worldCanvas.width, worldCanvas.height);

                // Draw resources and threats
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        const cell = this.env.state[y][x];
                        if (cell) {
                            if (cell.type === 'resource') {
                                worldCtx.fillStyle = cell.resourceType === 'food' ? 'green' : 'blue';
                            } else if (cell.type === 'threat') {
                                worldCtx.fillStyle = cell.threatType === 'predator' ? 'red' : 'orange';
                            }
                            worldCtx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        }
                    }
                }

                // Draw agents
                for (let agent of this.agents) {
                    if (agent.alive) {
                        worldCtx.fillStyle = 'purple';
                        worldCtx.fillRect(agent.position[0] * CELL_SIZE, agent.position[1] * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                }
            }
        }

        new Simulation();
    </script>
</body>
</html>
